{"ast":null,"code":"/**\n * This work is licensed under the W3C Software and Document License\n * (http://www.w3.org/Consortium/Legal/2015/copyright-software-and-document).\n */\n(function () {\n  // Return early if we're not running inside of the browser.\n  if (typeof window === 'undefined') {\n    return;\n  } // Convenience function for converting NodeLists.\n\n  /** @type {typeof Array.prototype.slice} */\n\n\n  const slice = Array.prototype.slice;\n  /**\n   * IE has a non-standard name for \"matches\".\n   * @type {typeof Element.prototype.matches}\n   */\n\n  const matches = Element.prototype.matches || Element.prototype.msMatchesSelector;\n  /** @type {string} */\n\n  const _focusableElementsString = ['a[href]', 'area[href]', 'input:not([disabled])', 'select:not([disabled])', 'textarea:not([disabled])', 'button:not([disabled])', 'details', 'summary', 'iframe', 'object', 'embed', '[contenteditable]'].join(',');\n  /**\n   * `InertRoot` manages a single inert subtree, i.e. a DOM subtree whose root element has an `inert`\n   * attribute.\n   *\n   * Its main functions are:\n   *\n   * - to create and maintain a set of managed `InertNode`s, including when mutations occur in the\n   *   subtree. The `makeSubtreeUnfocusable()` method handles collecting `InertNode`s via registering\n   *   each focusable node in the subtree with the singleton `InertManager` which manages all known\n   *   focusable nodes within inert subtrees. `InertManager` ensures that a single `InertNode`\n   *   instance exists for each focusable node which has at least one inert root as an ancestor.\n   *\n   * - to notify all managed `InertNode`s when this subtree stops being inert (i.e. when the `inert`\n   *   attribute is removed from the root node). This is handled in the destructor, which calls the\n   *   `deregister` method on `InertManager` for each managed inert node.\n   */\n\n\n  class InertRoot {\n    /**\n     * @param {!Element} rootElement The Element at the root of the inert subtree.\n     * @param {!InertManager} inertManager The global singleton InertManager object.\n     */\n    constructor(rootElement, inertManager) {\n      /** @type {!InertManager} */\n      this._inertManager = inertManager;\n      /** @type {!Element} */\n\n      this._rootElement = rootElement;\n      /**\n       * @type {!Set<!InertNode>}\n       * All managed focusable nodes in this InertRoot's subtree.\n       */\n\n      this._managedNodes = new Set(); // Make the subtree hidden from assistive technology\n\n      if (this._rootElement.hasAttribute('aria-hidden')) {\n        /** @type {?string} */\n        this._savedAriaHidden = this._rootElement.getAttribute('aria-hidden');\n      } else {\n        this._savedAriaHidden = null;\n      }\n\n      this._rootElement.setAttribute('aria-hidden', 'true'); // Make all focusable elements in the subtree unfocusable and add them to _managedNodes\n\n\n      this._makeSubtreeUnfocusable(this._rootElement); // Watch for:\n      // - any additions in the subtree: make them unfocusable too\n      // - any removals from the subtree: remove them from this inert root's managed nodes\n      // - attribute changes: if `tabindex` is added, or removed from an intrinsically focusable\n      //   element, make that node a managed node.\n\n\n      this._observer = new MutationObserver(this._onMutation.bind(this));\n\n      this._observer.observe(this._rootElement, {\n        attributes: true,\n        childList: true,\n        subtree: true\n      });\n    }\n    /**\n     * Call this whenever this object is about to become obsolete.  This unwinds all of the state\n     * stored in this object and updates the state of all of the managed nodes.\n     */\n\n\n    destructor() {\n      this._observer.disconnect();\n\n      if (this._rootElement) {\n        if (this._savedAriaHidden !== null) {\n          this._rootElement.setAttribute('aria-hidden', this._savedAriaHidden);\n        } else {\n          this._rootElement.removeAttribute('aria-hidden');\n        }\n      }\n\n      this._managedNodes.forEach(function (inertNode) {\n        this._unmanageNode(inertNode.node);\n      }, this); // Note we cast the nulls to the ANY type here because:\n      // 1) We want the class properties to be declared as non-null, or else we\n      //    need even more casts throughout this code. All bets are off if an\n      //    instance has been destroyed and a method is called.\n      // 2) We don't want to cast \"this\", because we want type-aware optimizations\n      //    to know which properties we're setting.\n\n\n      this._observer =\n      /** @type {?} */\n      null;\n      this._rootElement =\n      /** @type {?} */\n      null;\n      this._managedNodes =\n      /** @type {?} */\n      null;\n      this._inertManager =\n      /** @type {?} */\n      null;\n    }\n    /**\n     * @return {!Set<!InertNode>} A copy of this InertRoot's managed nodes set.\n     */\n\n\n    get managedNodes() {\n      return new Set(this._managedNodes);\n    }\n    /** @return {boolean} */\n\n\n    get hasSavedAriaHidden() {\n      return this._savedAriaHidden !== null;\n    }\n    /** @param {?string} ariaHidden */\n\n\n    set savedAriaHidden(ariaHidden) {\n      this._savedAriaHidden = ariaHidden;\n    }\n    /** @return {?string} */\n\n\n    get savedAriaHidden() {\n      return this._savedAriaHidden;\n    }\n    /**\n     * @param {!Node} startNode\n     */\n\n\n    _makeSubtreeUnfocusable(startNode) {\n      composedTreeWalk(startNode, node => this._visitNode(node));\n      let activeElement = document.activeElement;\n\n      if (!document.body.contains(startNode)) {\n        // startNode may be in shadow DOM, so find its nearest shadowRoot to get the activeElement.\n        let node = startNode;\n        /** @type {!ShadowRoot|undefined} */\n\n        let root = undefined;\n\n        while (node) {\n          if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n            root =\n            /** @type {!ShadowRoot} */\n            node;\n            break;\n          }\n\n          node = node.parentNode;\n        }\n\n        if (root) {\n          activeElement = root.activeElement;\n        }\n      }\n\n      if (startNode.contains(activeElement)) {\n        activeElement.blur(); // In IE11, if an element is already focused, and then set to tabindex=-1\n        // calling blur() will not actually move the focus.\n        // To work around this we call focus() on the body instead.\n\n        if (activeElement === document.activeElement) {\n          document.body.focus();\n        }\n      }\n    }\n    /**\n     * @param {!Node} node\n     */\n\n\n    _visitNode(node) {\n      if (node.nodeType !== Node.ELEMENT_NODE) {\n        return;\n      }\n\n      const element =\n      /** @type {!Element} */\n      node; // If a descendant inert root becomes un-inert, its descendants will still be inert because of\n      // this inert root, so all of its managed nodes need to be adopted by this InertRoot.\n\n      if (element !== this._rootElement && element.hasAttribute('inert')) {\n        this._adoptInertRoot(element);\n      }\n\n      if (matches.call(element, _focusableElementsString) || element.hasAttribute('tabindex')) {\n        this._manageNode(element);\n      }\n    }\n    /**\n     * Register the given node with this InertRoot and with InertManager.\n     * @param {!Node} node\n     */\n\n\n    _manageNode(node) {\n      const inertNode = this._inertManager.register(node, this);\n\n      this._managedNodes.add(inertNode);\n    }\n    /**\n     * Unregister the given node with this InertRoot and with InertManager.\n     * @param {!Node} node\n     */\n\n\n    _unmanageNode(node) {\n      const inertNode = this._inertManager.deregister(node, this);\n\n      if (inertNode) {\n        this._managedNodes.delete(inertNode);\n      }\n    }\n    /**\n     * Unregister the entire subtree starting at `startNode`.\n     * @param {!Node} startNode\n     */\n\n\n    _unmanageSubtree(startNode) {\n      composedTreeWalk(startNode, node => this._unmanageNode(node));\n    }\n    /**\n     * If a descendant node is found with an `inert` attribute, adopt its managed nodes.\n     * @param {!Element} node\n     */\n\n\n    _adoptInertRoot(node) {\n      let inertSubroot = this._inertManager.getInertRoot(node); // During initialisation this inert root may not have been registered yet,\n      // so register it now if need be.\n\n\n      if (!inertSubroot) {\n        this._inertManager.setInert(node, true);\n\n        inertSubroot = this._inertManager.getInertRoot(node);\n      }\n\n      inertSubroot.managedNodes.forEach(function (savedInertNode) {\n        this._manageNode(savedInertNode.node);\n      }, this);\n    }\n    /**\n     * Callback used when mutation observer detects subtree additions, removals, or attribute changes.\n     * @param {!Array<!MutationRecord>} records\n     * @param {!MutationObserver} self\n     */\n\n\n    _onMutation(records, self) {\n      records.forEach(function (record) {\n        const target =\n        /** @type {!Element} */\n        record.target;\n\n        if (record.type === 'childList') {\n          // Manage added nodes\n          slice.call(record.addedNodes).forEach(function (node) {\n            this._makeSubtreeUnfocusable(node);\n          }, this); // Un-manage removed nodes\n\n          slice.call(record.removedNodes).forEach(function (node) {\n            this._unmanageSubtree(node);\n          }, this);\n        } else if (record.type === 'attributes') {\n          if (record.attributeName === 'tabindex') {\n            // Re-initialise inert node if tabindex changes\n            this._manageNode(target);\n          } else if (target !== this._rootElement && record.attributeName === 'inert' && target.hasAttribute('inert')) {\n            // If a new inert root is added, adopt its managed nodes and make sure it knows about the\n            // already managed nodes from this inert subroot.\n            this._adoptInertRoot(target);\n\n            const inertSubroot = this._inertManager.getInertRoot(target);\n\n            this._managedNodes.forEach(function (managedNode) {\n              if (target.contains(managedNode.node)) {\n                inertSubroot._manageNode(managedNode.node);\n              }\n            });\n          }\n        }\n      }, this);\n    }\n\n  }\n  /**\n   * `InertNode` initialises and manages a single inert node.\n   * A node is inert if it is a descendant of one or more inert root elements.\n   *\n   * On construction, `InertNode` saves the existing `tabindex` value for the node, if any, and\n   * either removes the `tabindex` attribute or sets it to `-1`, depending on whether the element\n   * is intrinsically focusable or not.\n   *\n   * `InertNode` maintains a set of `InertRoot`s which are descendants of this `InertNode`. When an\n   * `InertRoot` is destroyed, and calls `InertManager.deregister()`, the `InertManager` notifies the\n   * `InertNode` via `removeInertRoot()`, which in turn destroys the `InertNode` if no `InertRoot`s\n   * remain in the set. On destruction, `InertNode` reinstates the stored `tabindex` if one exists,\n   * or removes the `tabindex` attribute if the element is intrinsically focusable.\n   */\n\n\n  class InertNode {\n    /**\n     * @param {!Node} node A focusable element to be made inert.\n     * @param {!InertRoot} inertRoot The inert root element associated with this inert node.\n     */\n    constructor(node, inertRoot) {\n      /** @type {!Node} */\n      this._node = node;\n      /** @type {boolean} */\n\n      this._overrodeFocusMethod = false;\n      /**\n       * @type {!Set<!InertRoot>} The set of descendant inert roots.\n       *    If and only if this set becomes empty, this node is no longer inert.\n       */\n\n      this._inertRoots = new Set([inertRoot]);\n      /** @type {?number} */\n\n      this._savedTabIndex = null;\n      /** @type {boolean} */\n\n      this._destroyed = false; // Save any prior tabindex info and make this node untabbable\n\n      this.ensureUntabbable();\n    }\n    /**\n     * Call this whenever this object is about to become obsolete.\n     * This makes the managed node focusable again and deletes all of the previously stored state.\n     */\n\n\n    destructor() {\n      this._throwIfDestroyed();\n\n      if (this._node && this._node.nodeType === Node.ELEMENT_NODE) {\n        const element =\n        /** @type {!Element} */\n        this._node;\n\n        if (this._savedTabIndex !== null) {\n          element.setAttribute('tabindex', this._savedTabIndex);\n        } else {\n          element.removeAttribute('tabindex');\n        } // Use `delete` to restore native focus method.\n\n\n        if (this._overrodeFocusMethod) {\n          delete element.focus;\n        }\n      } // See note in InertRoot.destructor for why we cast these nulls to ANY.\n\n\n      this._node =\n      /** @type {?} */\n      null;\n      this._inertRoots =\n      /** @type {?} */\n      null;\n      this._destroyed = true;\n    }\n    /**\n     * @type {boolean} Whether this object is obsolete because the managed node is no longer inert.\n     * If the object has been destroyed, any attempt to access it will cause an exception.\n     */\n\n\n    get destroyed() {\n      return (\n        /** @type {!InertNode} */\n        this._destroyed\n      );\n    }\n    /**\n     * Throw if user tries to access destroyed InertNode.\n     */\n\n\n    _throwIfDestroyed() {\n      if (this.destroyed) {\n        throw new Error('Trying to access destroyed InertNode');\n      }\n    }\n    /** @return {boolean} */\n\n\n    get hasSavedTabIndex() {\n      return this._savedTabIndex !== null;\n    }\n    /** @return {!Node} */\n\n\n    get node() {\n      this._throwIfDestroyed();\n\n      return this._node;\n    }\n    /** @param {?number} tabIndex */\n\n\n    set savedTabIndex(tabIndex) {\n      this._throwIfDestroyed();\n\n      this._savedTabIndex = tabIndex;\n    }\n    /** @return {?number} */\n\n\n    get savedTabIndex() {\n      this._throwIfDestroyed();\n\n      return this._savedTabIndex;\n    }\n    /** Save the existing tabindex value and make the node untabbable and unfocusable */\n\n\n    ensureUntabbable() {\n      if (this.node.nodeType !== Node.ELEMENT_NODE) {\n        return;\n      }\n\n      const element =\n      /** @type {!Element} */\n      this.node;\n\n      if (matches.call(element, _focusableElementsString)) {\n        if (\n        /** @type {!HTMLElement} */\n        element.tabIndex === -1 && this.hasSavedTabIndex) {\n          return;\n        }\n\n        if (element.hasAttribute('tabindex')) {\n          this._savedTabIndex =\n          /** @type {!HTMLElement} */\n          element.tabIndex;\n        }\n\n        element.setAttribute('tabindex', '-1');\n\n        if (element.nodeType === Node.ELEMENT_NODE) {\n          element.focus = function () {};\n\n          this._overrodeFocusMethod = true;\n        }\n      } else if (element.hasAttribute('tabindex')) {\n        this._savedTabIndex =\n        /** @type {!HTMLElement} */\n        element.tabIndex;\n        element.removeAttribute('tabindex');\n      }\n    }\n    /**\n     * Add another inert root to this inert node's set of managing inert roots.\n     * @param {!InertRoot} inertRoot\n     */\n\n\n    addInertRoot(inertRoot) {\n      this._throwIfDestroyed();\n\n      this._inertRoots.add(inertRoot);\n    }\n    /**\n     * Remove the given inert root from this inert node's set of managing inert roots.\n     * If the set of managing inert roots becomes empty, this node is no longer inert,\n     * so the object should be destroyed.\n     * @param {!InertRoot} inertRoot\n     */\n\n\n    removeInertRoot(inertRoot) {\n      this._throwIfDestroyed();\n\n      this._inertRoots.delete(inertRoot);\n\n      if (this._inertRoots.size === 0) {\n        this.destructor();\n      }\n    }\n\n  }\n  /**\n   * InertManager is a per-document singleton object which manages all inert roots and nodes.\n   *\n   * When an element becomes an inert root by having an `inert` attribute set and/or its `inert`\n   * property set to `true`, the `setInert` method creates an `InertRoot` object for the element.\n   * The `InertRoot` in turn registers itself as managing all of the element's focusable descendant\n   * nodes via the `register()` method. The `InertManager` ensures that a single `InertNode` instance\n   * is created for each such node, via the `_managedNodes` map.\n   */\n\n\n  class InertManager {\n    /**\n     * @param {!Document} document\n     */\n    constructor(document) {\n      if (!document) {\n        throw new Error('Missing required argument; InertManager needs to wrap a document.');\n      }\n      /** @type {!Document} */\n\n\n      this._document = document;\n      /**\n       * All managed nodes known to this InertManager. In a map to allow looking up by Node.\n       * @type {!Map<!Node, !InertNode>}\n       */\n\n      this._managedNodes = new Map();\n      /**\n       * All inert roots known to this InertManager. In a map to allow looking up by Node.\n       * @type {!Map<!Node, !InertRoot>}\n       */\n\n      this._inertRoots = new Map();\n      /**\n       * Observer for mutations on `document.body`.\n       * @type {!MutationObserver}\n       */\n\n      this._observer = new MutationObserver(this._watchForInert.bind(this)); // Add inert style.\n\n      addInertStyle(document.head || document.body || document.documentElement); // Wait for document to be loaded.\n\n      if (document.readyState === 'loading') {\n        document.addEventListener('DOMContentLoaded', this._onDocumentLoaded.bind(this));\n      } else {\n        this._onDocumentLoaded();\n      }\n    }\n    /**\n     * Set whether the given element should be an inert root or not.\n     * @param {!Element} root\n     * @param {boolean} inert\n     */\n\n\n    setInert(root, inert) {\n      if (inert) {\n        if (this._inertRoots.has(root)) {\n          // element is already inert\n          return;\n        }\n\n        const inertRoot = new InertRoot(root, this);\n        root.setAttribute('inert', '');\n\n        this._inertRoots.set(root, inertRoot); // If not contained in the document, it must be in a shadowRoot.\n        // Ensure inert styles are added there.\n\n\n        if (!this._document.body.contains(root)) {\n          let parent = root.parentNode;\n\n          while (parent) {\n            if (parent.nodeType === 11) {\n              addInertStyle(parent);\n            }\n\n            parent = parent.parentNode;\n          }\n        }\n      } else {\n        if (!this._inertRoots.has(root)) {\n          // element is already non-inert\n          return;\n        }\n\n        const inertRoot = this._inertRoots.get(root);\n\n        inertRoot.destructor();\n\n        this._inertRoots.delete(root);\n\n        root.removeAttribute('inert');\n      }\n    }\n    /**\n     * Get the InertRoot object corresponding to the given inert root element, if any.\n     * @param {!Node} element\n     * @return {!InertRoot|undefined}\n     */\n\n\n    getInertRoot(element) {\n      return this._inertRoots.get(element);\n    }\n    /**\n     * Register the given InertRoot as managing the given node.\n     * In the case where the node has a previously existing inert root, this inert root will\n     * be added to its set of inert roots.\n     * @param {!Node} node\n     * @param {!InertRoot} inertRoot\n     * @return {!InertNode} inertNode\n     */\n\n\n    register(node, inertRoot) {\n      let inertNode = this._managedNodes.get(node);\n\n      if (inertNode !== undefined) {\n        // node was already in an inert subtree\n        inertNode.addInertRoot(inertRoot);\n      } else {\n        inertNode = new InertNode(node, inertRoot);\n      }\n\n      this._managedNodes.set(node, inertNode);\n\n      return inertNode;\n    }\n    /**\n     * De-register the given InertRoot as managing the given inert node.\n     * Removes the inert root from the InertNode's set of managing inert roots, and remove the inert\n     * node from the InertManager's set of managed nodes if it is destroyed.\n     * If the node is not currently managed, this is essentially a no-op.\n     * @param {!Node} node\n     * @param {!InertRoot} inertRoot\n     * @return {?InertNode} The potentially destroyed InertNode associated with this node, if any.\n     */\n\n\n    deregister(node, inertRoot) {\n      const inertNode = this._managedNodes.get(node);\n\n      if (!inertNode) {\n        return null;\n      }\n\n      inertNode.removeInertRoot(inertRoot);\n\n      if (inertNode.destroyed) {\n        this._managedNodes.delete(node);\n      }\n\n      return inertNode;\n    }\n    /**\n     * Callback used when document has finished loading.\n     */\n\n\n    _onDocumentLoaded() {\n      // Find all inert roots in document and make them actually inert.\n      const inertElements = slice.call(this._document.querySelectorAll('[inert]'));\n      inertElements.forEach(function (inertElement) {\n        this.setInert(inertElement, true);\n      }, this); // Comment this out to use programmatic API only.\n\n      this._observer.observe(this._document.body || this._document.documentElement, {\n        attributes: true,\n        subtree: true,\n        childList: true\n      });\n    }\n    /**\n     * Callback used when mutation observer detects attribute changes.\n     * @param {!Array<!MutationRecord>} records\n     * @param {!MutationObserver} self\n     */\n\n\n    _watchForInert(records, self) {\n      const _this = this;\n\n      records.forEach(function (record) {\n        switch (record.type) {\n          case 'childList':\n            slice.call(record.addedNodes).forEach(function (node) {\n              if (node.nodeType !== Node.ELEMENT_NODE) {\n                return;\n              }\n\n              const inertElements = slice.call(node.querySelectorAll('[inert]'));\n\n              if (matches.call(node, '[inert]')) {\n                inertElements.unshift(node);\n              }\n\n              inertElements.forEach(function (inertElement) {\n                this.setInert(inertElement, true);\n              }, _this);\n            }, _this);\n            break;\n\n          case 'attributes':\n            if (record.attributeName !== 'inert') {\n              return;\n            }\n\n            const target =\n            /** @type {!Element} */\n            record.target;\n            const inert = target.hasAttribute('inert');\n\n            _this.setInert(target, inert);\n\n            break;\n        }\n      }, this);\n    }\n\n  }\n  /**\n   * Recursively walk the composed tree from |node|.\n   * @param {!Node} node\n   * @param {(function (!Element))=} callback Callback to be called for each element traversed,\n   *     before descending into child nodes.\n   * @param {?ShadowRoot=} shadowRootAncestor The nearest ShadowRoot ancestor, if any.\n   */\n\n\n  function composedTreeWalk(node, callback, shadowRootAncestor) {\n    if (node.nodeType == Node.ELEMENT_NODE) {\n      const element =\n      /** @type {!Element} */\n      node;\n\n      if (callback) {\n        callback(element);\n      } // Descend into node:\n      // If it has a ShadowRoot, ignore all child elements - these will be picked\n      // up by the <content> or <shadow> elements. Descend straight into the\n      // ShadowRoot.\n\n\n      const shadowRoot =\n      /** @type {!HTMLElement} */\n      element.shadowRoot;\n\n      if (shadowRoot) {\n        composedTreeWalk(shadowRoot, callback, shadowRoot);\n        return;\n      } // If it is a <content> element, descend into distributed elements - these\n      // are elements from outside the shadow root which are rendered inside the\n      // shadow DOM.\n\n\n      if (element.localName == 'content') {\n        const content =\n        /** @type {!HTMLContentElement} */\n        element; // Verifies if ShadowDom v0 is supported.\n\n        const distributedNodes = content.getDistributedNodes ? content.getDistributedNodes() : [];\n\n        for (let i = 0; i < distributedNodes.length; i++) {\n          composedTreeWalk(distributedNodes[i], callback, shadowRootAncestor);\n        }\n\n        return;\n      } // If it is a <slot> element, descend into assigned nodes - these\n      // are elements from outside the shadow root which are rendered inside the\n      // shadow DOM.\n\n\n      if (element.localName == 'slot') {\n        const slot =\n        /** @type {!HTMLSlotElement} */\n        element; // Verify if ShadowDom v1 is supported.\n\n        const distributedNodes = slot.assignedNodes ? slot.assignedNodes({\n          flatten: true\n        }) : [];\n\n        for (let i = 0; i < distributedNodes.length; i++) {\n          composedTreeWalk(distributedNodes[i], callback, shadowRootAncestor);\n        }\n\n        return;\n      }\n    } // If it is neither the parent of a ShadowRoot, a <content> element, a <slot>\n    // element, nor a <shadow> element recurse normally.\n\n\n    let child = node.firstChild;\n\n    while (child != null) {\n      composedTreeWalk(child, callback, shadowRootAncestor);\n      child = child.nextSibling;\n    }\n  }\n  /**\n   * Adds a style element to the node containing the inert specific styles\n   * @param {!Node} node\n   */\n\n\n  function addInertStyle(node) {\n    if (node.querySelector('style#inert-style, link#inert-style')) {\n      return;\n    }\n\n    const style = document.createElement('style');\n    style.setAttribute('id', 'inert-style');\n    style.textContent = '\\n' + '[inert] {\\n' + '  pointer-events: none;\\n' + '  cursor: default;\\n' + '}\\n' + '\\n' + '[inert], [inert] * {\\n' + '  -webkit-user-select: none;\\n' + '  -moz-user-select: none;\\n' + '  -ms-user-select: none;\\n' + '  user-select: none;\\n' + '}\\n';\n    node.appendChild(style);\n  }\n  /** @type {!InertManager} */\n\n\n  const inertManager = new InertManager(document);\n\n  if (!Element.prototype.hasOwnProperty('inert')) {\n    Object.defineProperty(Element.prototype, 'inert', {\n      enumerable: true,\n\n      /** @this {!Element} */\n      get: function () {\n        return this.hasAttribute('inert');\n      },\n\n      /** @this {!Element} */\n      set: function (inert) {\n        inertManager.setInert(this, inert);\n      }\n    });\n  }\n})();","map":{"version":3,"sources":["/Users/zionwang/Projects/consensus/node_modules/wicg-inert/src/inert.js"],"names":["window","slice","Array","prototype","matches","Element","msMatchesSelector","_focusableElementsString","join","InertRoot","constructor","rootElement","inertManager","_inertManager","_rootElement","_managedNodes","Set","hasAttribute","_savedAriaHidden","getAttribute","setAttribute","_makeSubtreeUnfocusable","_observer","MutationObserver","_onMutation","bind","observe","attributes","childList","subtree","destructor","disconnect","removeAttribute","forEach","inertNode","_unmanageNode","node","managedNodes","hasSavedAriaHidden","savedAriaHidden","ariaHidden","startNode","composedTreeWalk","_visitNode","activeElement","document","body","contains","root","undefined","nodeType","Node","DOCUMENT_FRAGMENT_NODE","parentNode","blur","focus","ELEMENT_NODE","element","_adoptInertRoot","call","_manageNode","register","add","deregister","delete","_unmanageSubtree","inertSubroot","getInertRoot","setInert","savedInertNode","records","self","record","target","type","addedNodes","removedNodes","attributeName","managedNode","InertNode","inertRoot","_node","_overrodeFocusMethod","_inertRoots","_savedTabIndex","_destroyed","ensureUntabbable","_throwIfDestroyed","destroyed","Error","hasSavedTabIndex","savedTabIndex","tabIndex","addInertRoot","removeInertRoot","size","InertManager","_document","Map","_watchForInert","addInertStyle","head","documentElement","readyState","addEventListener","_onDocumentLoaded","inert","has","set","parent","get","inertElements","querySelectorAll","inertElement","_this","unshift","callback","shadowRootAncestor","shadowRoot","localName","content","distributedNodes","getDistributedNodes","i","length","slot","assignedNodes","flatten","child","firstChild","nextSibling","querySelector","style","createElement","textContent","appendChild","hasOwnProperty","Object","defineProperty","enumerable"],"mappings":"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","sourcesContent":["/**\n * This work is licensed under the W3C Software and Document License\n * (http://www.w3.org/Consortium/Legal/2015/copyright-software-and-document).\n */\n\n(function() {\n  // Return early if we're not running inside of the browser.\n  if (typeof window === 'undefined') {\n    return;\n  }\n\n  // Convenience function for converting NodeLists.\n  /** @type {typeof Array.prototype.slice} */\n  const slice = Array.prototype.slice;\n\n  /**\n   * IE has a non-standard name for \"matches\".\n   * @type {typeof Element.prototype.matches}\n   */\n  const matches =\n      Element.prototype.matches || Element.prototype.msMatchesSelector;\n\n  /** @type {string} */\n  const _focusableElementsString = ['a[href]',\n                                    'area[href]',\n                                    'input:not([disabled])',\n                                    'select:not([disabled])',\n                                    'textarea:not([disabled])',\n                                    'button:not([disabled])',\n                                    'details',\n                                    'summary',\n                                    'iframe',\n                                    'object',\n                                    'embed',\n                                    '[contenteditable]'].join(',');\n\n  /**\n   * `InertRoot` manages a single inert subtree, i.e. a DOM subtree whose root element has an `inert`\n   * attribute.\n   *\n   * Its main functions are:\n   *\n   * - to create and maintain a set of managed `InertNode`s, including when mutations occur in the\n   *   subtree. The `makeSubtreeUnfocusable()` method handles collecting `InertNode`s via registering\n   *   each focusable node in the subtree with the singleton `InertManager` which manages all known\n   *   focusable nodes within inert subtrees. `InertManager` ensures that a single `InertNode`\n   *   instance exists for each focusable node which has at least one inert root as an ancestor.\n   *\n   * - to notify all managed `InertNode`s when this subtree stops being inert (i.e. when the `inert`\n   *   attribute is removed from the root node). This is handled in the destructor, which calls the\n   *   `deregister` method on `InertManager` for each managed inert node.\n   */\n  class InertRoot {\n    /**\n     * @param {!Element} rootElement The Element at the root of the inert subtree.\n     * @param {!InertManager} inertManager The global singleton InertManager object.\n     */\n    constructor(rootElement, inertManager) {\n      /** @type {!InertManager} */\n      this._inertManager = inertManager;\n\n      /** @type {!Element} */\n      this._rootElement = rootElement;\n\n      /**\n       * @type {!Set<!InertNode>}\n       * All managed focusable nodes in this InertRoot's subtree.\n       */\n      this._managedNodes = new Set();\n\n      // Make the subtree hidden from assistive technology\n      if (this._rootElement.hasAttribute('aria-hidden')) {\n        /** @type {?string} */\n        this._savedAriaHidden = this._rootElement.getAttribute('aria-hidden');\n      } else {\n        this._savedAriaHidden = null;\n      }\n      this._rootElement.setAttribute('aria-hidden', 'true');\n\n      // Make all focusable elements in the subtree unfocusable and add them to _managedNodes\n      this._makeSubtreeUnfocusable(this._rootElement);\n\n      // Watch for:\n      // - any additions in the subtree: make them unfocusable too\n      // - any removals from the subtree: remove them from this inert root's managed nodes\n      // - attribute changes: if `tabindex` is added, or removed from an intrinsically focusable\n      //   element, make that node a managed node.\n      this._observer = new MutationObserver(this._onMutation.bind(this));\n      this._observer.observe(this._rootElement, {attributes: true, childList: true, subtree: true});\n    }\n\n    /**\n     * Call this whenever this object is about to become obsolete.  This unwinds all of the state\n     * stored in this object and updates the state of all of the managed nodes.\n     */\n    destructor() {\n      this._observer.disconnect();\n\n      if (this._rootElement) {\n        if (this._savedAriaHidden !== null) {\n          this._rootElement.setAttribute('aria-hidden', this._savedAriaHidden);\n        } else {\n          this._rootElement.removeAttribute('aria-hidden');\n        }\n      }\n\n      this._managedNodes.forEach(function(inertNode) {\n        this._unmanageNode(inertNode.node);\n      }, this);\n\n      // Note we cast the nulls to the ANY type here because:\n      // 1) We want the class properties to be declared as non-null, or else we\n      //    need even more casts throughout this code. All bets are off if an\n      //    instance has been destroyed and a method is called.\n      // 2) We don't want to cast \"this\", because we want type-aware optimizations\n      //    to know which properties we're setting.\n      this._observer = /** @type {?} */ (null);\n      this._rootElement = /** @type {?} */ (null);\n      this._managedNodes = /** @type {?} */ (null);\n      this._inertManager = /** @type {?} */ (null);\n    }\n\n    /**\n     * @return {!Set<!InertNode>} A copy of this InertRoot's managed nodes set.\n     */\n    get managedNodes() {\n      return new Set(this._managedNodes);\n    }\n\n    /** @return {boolean} */\n    get hasSavedAriaHidden() {\n      return this._savedAriaHidden !== null;\n    }\n\n    /** @param {?string} ariaHidden */\n    set savedAriaHidden(ariaHidden) {\n      this._savedAriaHidden = ariaHidden;\n    }\n\n    /** @return {?string} */\n    get savedAriaHidden() {\n      return this._savedAriaHidden;\n    }\n\n    /**\n     * @param {!Node} startNode\n     */\n    _makeSubtreeUnfocusable(startNode) {\n      composedTreeWalk(startNode, (node) => this._visitNode(node));\n\n      let activeElement = document.activeElement;\n\n      if (!document.body.contains(startNode)) {\n        // startNode may be in shadow DOM, so find its nearest shadowRoot to get the activeElement.\n        let node = startNode;\n        /** @type {!ShadowRoot|undefined} */\n        let root = undefined;\n        while (node) {\n          if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n            root = /** @type {!ShadowRoot} */ (node);\n            break;\n          }\n          node = node.parentNode;\n        }\n        if (root) {\n          activeElement = root.activeElement;\n        }\n      }\n      if (startNode.contains(activeElement)) {\n        activeElement.blur();\n        // In IE11, if an element is already focused, and then set to tabindex=-1\n        // calling blur() will not actually move the focus.\n        // To work around this we call focus() on the body instead.\n        if (activeElement === document.activeElement) {\n          document.body.focus();\n        }\n      }\n    }\n\n    /**\n     * @param {!Node} node\n     */\n    _visitNode(node) {\n      if (node.nodeType !== Node.ELEMENT_NODE) {\n        return;\n      }\n      const element = /** @type {!Element} */ (node);\n\n      // If a descendant inert root becomes un-inert, its descendants will still be inert because of\n      // this inert root, so all of its managed nodes need to be adopted by this InertRoot.\n      if (element !== this._rootElement && element.hasAttribute('inert')) {\n        this._adoptInertRoot(element);\n      }\n\n      if (matches.call(element, _focusableElementsString) || element.hasAttribute('tabindex')) {\n        this._manageNode(element);\n      }\n    }\n\n    /**\n     * Register the given node with this InertRoot and with InertManager.\n     * @param {!Node} node\n     */\n    _manageNode(node) {\n      const inertNode = this._inertManager.register(node, this);\n      this._managedNodes.add(inertNode);\n    }\n\n    /**\n     * Unregister the given node with this InertRoot and with InertManager.\n     * @param {!Node} node\n     */\n    _unmanageNode(node) {\n      const inertNode = this._inertManager.deregister(node, this);\n      if (inertNode) {\n        this._managedNodes.delete(inertNode);\n      }\n    }\n\n    /**\n     * Unregister the entire subtree starting at `startNode`.\n     * @param {!Node} startNode\n     */\n    _unmanageSubtree(startNode) {\n      composedTreeWalk(startNode, (node) => this._unmanageNode(node));\n    }\n\n    /**\n     * If a descendant node is found with an `inert` attribute, adopt its managed nodes.\n     * @param {!Element} node\n     */\n    _adoptInertRoot(node) {\n      let inertSubroot = this._inertManager.getInertRoot(node);\n\n      // During initialisation this inert root may not have been registered yet,\n      // so register it now if need be.\n      if (!inertSubroot) {\n        this._inertManager.setInert(node, true);\n        inertSubroot = this._inertManager.getInertRoot(node);\n      }\n\n      inertSubroot.managedNodes.forEach(function(savedInertNode) {\n        this._manageNode(savedInertNode.node);\n      }, this);\n    }\n\n    /**\n     * Callback used when mutation observer detects subtree additions, removals, or attribute changes.\n     * @param {!Array<!MutationRecord>} records\n     * @param {!MutationObserver} self\n     */\n    _onMutation(records, self) {\n      records.forEach(function(record) {\n        const target = /** @type {!Element} */ (record.target);\n        if (record.type === 'childList') {\n          // Manage added nodes\n          slice.call(record.addedNodes).forEach(function(node) {\n            this._makeSubtreeUnfocusable(node);\n          }, this);\n\n          // Un-manage removed nodes\n          slice.call(record.removedNodes).forEach(function(node) {\n            this._unmanageSubtree(node);\n          }, this);\n        } else if (record.type === 'attributes') {\n          if (record.attributeName === 'tabindex') {\n            // Re-initialise inert node if tabindex changes\n            this._manageNode(target);\n          } else if (target !== this._rootElement &&\n                    record.attributeName === 'inert' &&\n                    target.hasAttribute('inert')) {\n            // If a new inert root is added, adopt its managed nodes and make sure it knows about the\n            // already managed nodes from this inert subroot.\n            this._adoptInertRoot(target);\n            const inertSubroot = this._inertManager.getInertRoot(target);\n            this._managedNodes.forEach(function(managedNode) {\n              if (target.contains(managedNode.node)) {\n                inertSubroot._manageNode(managedNode.node);\n              }\n            });\n          }\n        }\n      }, this);\n    }\n  }\n\n  /**\n   * `InertNode` initialises and manages a single inert node.\n   * A node is inert if it is a descendant of one or more inert root elements.\n   *\n   * On construction, `InertNode` saves the existing `tabindex` value for the node, if any, and\n   * either removes the `tabindex` attribute or sets it to `-1`, depending on whether the element\n   * is intrinsically focusable or not.\n   *\n   * `InertNode` maintains a set of `InertRoot`s which are descendants of this `InertNode`. When an\n   * `InertRoot` is destroyed, and calls `InertManager.deregister()`, the `InertManager` notifies the\n   * `InertNode` via `removeInertRoot()`, which in turn destroys the `InertNode` if no `InertRoot`s\n   * remain in the set. On destruction, `InertNode` reinstates the stored `tabindex` if one exists,\n   * or removes the `tabindex` attribute if the element is intrinsically focusable.\n   */\n  class InertNode {\n    /**\n     * @param {!Node} node A focusable element to be made inert.\n     * @param {!InertRoot} inertRoot The inert root element associated with this inert node.\n     */\n    constructor(node, inertRoot) {\n      /** @type {!Node} */\n      this._node = node;\n\n      /** @type {boolean} */\n      this._overrodeFocusMethod = false;\n\n      /**\n       * @type {!Set<!InertRoot>} The set of descendant inert roots.\n       *    If and only if this set becomes empty, this node is no longer inert.\n       */\n      this._inertRoots = new Set([inertRoot]);\n\n      /** @type {?number} */\n      this._savedTabIndex = null;\n\n      /** @type {boolean} */\n      this._destroyed = false;\n\n      // Save any prior tabindex info and make this node untabbable\n      this.ensureUntabbable();\n    }\n\n    /**\n     * Call this whenever this object is about to become obsolete.\n     * This makes the managed node focusable again and deletes all of the previously stored state.\n     */\n    destructor() {\n      this._throwIfDestroyed();\n\n      if (this._node && this._node.nodeType === Node.ELEMENT_NODE) {\n        const element = /** @type {!Element} */ (this._node);\n        if (this._savedTabIndex !== null) {\n          element.setAttribute('tabindex', this._savedTabIndex);\n        } else {\n          element.removeAttribute('tabindex');\n        }\n\n        // Use `delete` to restore native focus method.\n        if (this._overrodeFocusMethod) {\n          delete element.focus;\n        }\n      }\n\n      // See note in InertRoot.destructor for why we cast these nulls to ANY.\n      this._node = /** @type {?} */ (null);\n      this._inertRoots = /** @type {?} */ (null);\n      this._destroyed = true;\n    }\n\n    /**\n     * @type {boolean} Whether this object is obsolete because the managed node is no longer inert.\n     * If the object has been destroyed, any attempt to access it will cause an exception.\n     */\n    get destroyed() {\n      return /** @type {!InertNode} */ (this)._destroyed;\n    }\n\n    /**\n     * Throw if user tries to access destroyed InertNode.\n     */\n    _throwIfDestroyed() {\n      if (this.destroyed) {\n        throw new Error('Trying to access destroyed InertNode');\n      }\n    }\n\n    /** @return {boolean} */\n    get hasSavedTabIndex() {\n      return this._savedTabIndex !== null;\n    }\n\n    /** @return {!Node} */\n    get node() {\n      this._throwIfDestroyed();\n      return this._node;\n    }\n\n    /** @param {?number} tabIndex */\n    set savedTabIndex(tabIndex) {\n      this._throwIfDestroyed();\n      this._savedTabIndex = tabIndex;\n    }\n\n    /** @return {?number} */\n    get savedTabIndex() {\n      this._throwIfDestroyed();\n      return this._savedTabIndex;\n    }\n\n    /** Save the existing tabindex value and make the node untabbable and unfocusable */\n    ensureUntabbable() {\n      if (this.node.nodeType !== Node.ELEMENT_NODE) {\n        return;\n      }\n      const element = /** @type {!Element} */ (this.node);\n      if (matches.call(element, _focusableElementsString)) {\n        if (/** @type {!HTMLElement} */ (element).tabIndex === -1 &&\n            this.hasSavedTabIndex) {\n          return;\n        }\n\n        if (element.hasAttribute('tabindex')) {\n          this._savedTabIndex = /** @type {!HTMLElement} */ (element).tabIndex;\n        }\n        element.setAttribute('tabindex', '-1');\n        if (element.nodeType === Node.ELEMENT_NODE) {\n          element.focus = function() {};\n          this._overrodeFocusMethod = true;\n        }\n      } else if (element.hasAttribute('tabindex')) {\n        this._savedTabIndex = /** @type {!HTMLElement} */ (element).tabIndex;\n        element.removeAttribute('tabindex');\n      }\n    }\n\n    /**\n     * Add another inert root to this inert node's set of managing inert roots.\n     * @param {!InertRoot} inertRoot\n     */\n    addInertRoot(inertRoot) {\n      this._throwIfDestroyed();\n      this._inertRoots.add(inertRoot);\n    }\n\n    /**\n     * Remove the given inert root from this inert node's set of managing inert roots.\n     * If the set of managing inert roots becomes empty, this node is no longer inert,\n     * so the object should be destroyed.\n     * @param {!InertRoot} inertRoot\n     */\n    removeInertRoot(inertRoot) {\n      this._throwIfDestroyed();\n      this._inertRoots.delete(inertRoot);\n      if (this._inertRoots.size === 0) {\n        this.destructor();\n      }\n    }\n  }\n\n  /**\n   * InertManager is a per-document singleton object which manages all inert roots and nodes.\n   *\n   * When an element becomes an inert root by having an `inert` attribute set and/or its `inert`\n   * property set to `true`, the `setInert` method creates an `InertRoot` object for the element.\n   * The `InertRoot` in turn registers itself as managing all of the element's focusable descendant\n   * nodes via the `register()` method. The `InertManager` ensures that a single `InertNode` instance\n   * is created for each such node, via the `_managedNodes` map.\n   */\n  class InertManager {\n    /**\n     * @param {!Document} document\n     */\n    constructor(document) {\n      if (!document) {\n        throw new Error('Missing required argument; InertManager needs to wrap a document.');\n      }\n\n      /** @type {!Document} */\n      this._document = document;\n\n      /**\n       * All managed nodes known to this InertManager. In a map to allow looking up by Node.\n       * @type {!Map<!Node, !InertNode>}\n       */\n      this._managedNodes = new Map();\n\n      /**\n       * All inert roots known to this InertManager. In a map to allow looking up by Node.\n       * @type {!Map<!Node, !InertRoot>}\n       */\n      this._inertRoots = new Map();\n\n      /**\n       * Observer for mutations on `document.body`.\n       * @type {!MutationObserver}\n       */\n      this._observer = new MutationObserver(this._watchForInert.bind(this));\n\n      // Add inert style.\n      addInertStyle(document.head || document.body || document.documentElement);\n\n      // Wait for document to be loaded.\n      if (document.readyState === 'loading') {\n        document.addEventListener('DOMContentLoaded', this._onDocumentLoaded.bind(this));\n      } else {\n        this._onDocumentLoaded();\n      }\n    }\n\n    /**\n     * Set whether the given element should be an inert root or not.\n     * @param {!Element} root\n     * @param {boolean} inert\n     */\n    setInert(root, inert) {\n      if (inert) {\n        if (this._inertRoots.has(root)) { // element is already inert\n          return;\n        }\n\n        const inertRoot = new InertRoot(root, this);\n        root.setAttribute('inert', '');\n        this._inertRoots.set(root, inertRoot);\n        // If not contained in the document, it must be in a shadowRoot.\n        // Ensure inert styles are added there.\n        if (!this._document.body.contains(root)) {\n          let parent = root.parentNode;\n          while (parent) {\n            if (parent.nodeType === 11) {\n              addInertStyle(parent);\n            }\n            parent = parent.parentNode;\n          }\n        }\n      } else {\n        if (!this._inertRoots.has(root)) { // element is already non-inert\n          return;\n        }\n\n        const inertRoot = this._inertRoots.get(root);\n        inertRoot.destructor();\n        this._inertRoots.delete(root);\n        root.removeAttribute('inert');\n      }\n    }\n\n    /**\n     * Get the InertRoot object corresponding to the given inert root element, if any.\n     * @param {!Node} element\n     * @return {!InertRoot|undefined}\n     */\n    getInertRoot(element) {\n      return this._inertRoots.get(element);\n    }\n\n    /**\n     * Register the given InertRoot as managing the given node.\n     * In the case where the node has a previously existing inert root, this inert root will\n     * be added to its set of inert roots.\n     * @param {!Node} node\n     * @param {!InertRoot} inertRoot\n     * @return {!InertNode} inertNode\n     */\n    register(node, inertRoot) {\n      let inertNode = this._managedNodes.get(node);\n      if (inertNode !== undefined) { // node was already in an inert subtree\n        inertNode.addInertRoot(inertRoot);\n      } else {\n        inertNode = new InertNode(node, inertRoot);\n      }\n\n      this._managedNodes.set(node, inertNode);\n\n      return inertNode;\n    }\n\n    /**\n     * De-register the given InertRoot as managing the given inert node.\n     * Removes the inert root from the InertNode's set of managing inert roots, and remove the inert\n     * node from the InertManager's set of managed nodes if it is destroyed.\n     * If the node is not currently managed, this is essentially a no-op.\n     * @param {!Node} node\n     * @param {!InertRoot} inertRoot\n     * @return {?InertNode} The potentially destroyed InertNode associated with this node, if any.\n     */\n    deregister(node, inertRoot) {\n      const inertNode = this._managedNodes.get(node);\n      if (!inertNode) {\n        return null;\n      }\n\n      inertNode.removeInertRoot(inertRoot);\n      if (inertNode.destroyed) {\n        this._managedNodes.delete(node);\n      }\n\n      return inertNode;\n    }\n\n    /**\n     * Callback used when document has finished loading.\n     */\n    _onDocumentLoaded() {\n      // Find all inert roots in document and make them actually inert.\n      const inertElements = slice.call(this._document.querySelectorAll('[inert]'));\n      inertElements.forEach(function(inertElement) {\n        this.setInert(inertElement, true);\n      }, this);\n\n      // Comment this out to use programmatic API only.\n      this._observer.observe(this._document.body || this._document.documentElement, {attributes: true, subtree: true, childList: true});\n    }\n\n    /**\n     * Callback used when mutation observer detects attribute changes.\n     * @param {!Array<!MutationRecord>} records\n     * @param {!MutationObserver} self\n     */\n    _watchForInert(records, self) {\n      const _this = this;\n      records.forEach(function(record) {\n        switch (record.type) {\n        case 'childList':\n          slice.call(record.addedNodes).forEach(function(node) {\n            if (node.nodeType !== Node.ELEMENT_NODE) {\n              return;\n            }\n            const inertElements = slice.call(node.querySelectorAll('[inert]'));\n            if (matches.call(node, '[inert]')) {\n              inertElements.unshift(node);\n            }\n            inertElements.forEach(function(inertElement) {\n              this.setInert(inertElement, true);\n            }, _this);\n          }, _this);\n          break;\n        case 'attributes':\n          if (record.attributeName !== 'inert') {\n            return;\n          }\n          const target = /** @type {!Element} */ (record.target);\n          const inert = target.hasAttribute('inert');\n          _this.setInert(target, inert);\n          break;\n        }\n      }, this);\n    }\n  }\n\n  /**\n   * Recursively walk the composed tree from |node|.\n   * @param {!Node} node\n   * @param {(function (!Element))=} callback Callback to be called for each element traversed,\n   *     before descending into child nodes.\n   * @param {?ShadowRoot=} shadowRootAncestor The nearest ShadowRoot ancestor, if any.\n   */\n  function composedTreeWalk(node, callback, shadowRootAncestor) {\n    if (node.nodeType == Node.ELEMENT_NODE) {\n      const element = /** @type {!Element} */ (node);\n      if (callback) {\n        callback(element);\n      }\n\n      // Descend into node:\n      // If it has a ShadowRoot, ignore all child elements - these will be picked\n      // up by the <content> or <shadow> elements. Descend straight into the\n      // ShadowRoot.\n      const shadowRoot = /** @type {!HTMLElement} */ (element).shadowRoot;\n      if (shadowRoot) {\n        composedTreeWalk(shadowRoot, callback, shadowRoot);\n        return;\n      }\n\n      // If it is a <content> element, descend into distributed elements - these\n      // are elements from outside the shadow root which are rendered inside the\n      // shadow DOM.\n      if (element.localName == 'content') {\n        const content = /** @type {!HTMLContentElement} */ (element);\n        // Verifies if ShadowDom v0 is supported.\n        const distributedNodes = content.getDistributedNodes ?\n          content.getDistributedNodes() : [];\n        for (let i = 0; i < distributedNodes.length; i++) {\n          composedTreeWalk(distributedNodes[i], callback, shadowRootAncestor);\n        }\n        return;\n      }\n\n      // If it is a <slot> element, descend into assigned nodes - these\n      // are elements from outside the shadow root which are rendered inside the\n      // shadow DOM.\n      if (element.localName == 'slot') {\n        const slot = /** @type {!HTMLSlotElement} */ (element);\n        // Verify if ShadowDom v1 is supported.\n        const distributedNodes = slot.assignedNodes ?\n          slot.assignedNodes({flatten: true}) : [];\n        for (let i = 0; i < distributedNodes.length; i++) {\n          composedTreeWalk(distributedNodes[i], callback, shadowRootAncestor);\n        }\n        return;\n      }\n    }\n\n    // If it is neither the parent of a ShadowRoot, a <content> element, a <slot>\n    // element, nor a <shadow> element recurse normally.\n    let child = node.firstChild;\n    while (child != null) {\n      composedTreeWalk(child, callback, shadowRootAncestor);\n      child = child.nextSibling;\n    }\n  }\n\n  /**\n   * Adds a style element to the node containing the inert specific styles\n   * @param {!Node} node\n   */\n  function addInertStyle(node) {\n    if (node.querySelector('style#inert-style, link#inert-style')) {\n      return;\n    }\n    const style = document.createElement('style');\n    style.setAttribute('id', 'inert-style');\n    style.textContent = '\\n'+\n                        '[inert] {\\n' +\n                        '  pointer-events: none;\\n' +\n                        '  cursor: default;\\n' +\n                        '}\\n' +\n                        '\\n' +\n                        '[inert], [inert] * {\\n' +\n                        '  -webkit-user-select: none;\\n' +\n                        '  -moz-user-select: none;\\n' +\n                        '  -ms-user-select: none;\\n' +\n                        '  user-select: none;\\n' +\n                        '}\\n';\n    node.appendChild(style);\n  }\n\n  /** @type {!InertManager} */\n  const inertManager = new InertManager(document);\n\n  if (!Element.prototype.hasOwnProperty('inert')) {\n    Object.defineProperty(Element.prototype, 'inert', {\n      enumerable: true,\n      /** @this {!Element} */\n      get: function() {\n        return this.hasAttribute('inert');\n      },\n      /** @this {!Element} */\n      set: function(inert) {\n        inertManager.setInert(this, inert);\n      },\n    });\n  }\n})();\n"]},"metadata":{},"sourceType":"script"}