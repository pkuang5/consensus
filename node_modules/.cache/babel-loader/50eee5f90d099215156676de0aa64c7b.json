{"ast":null,"code":"import React from 'react';\nexport var getValidChildren = function getValidChildren(children) {\n  // .toArray automatically removes invalid React children\n  return React.Children.toArray(children);\n};\n\nvar getMax = function getMax(a, b) {\n  return a > b ? a : b;\n};\n\nvar getHeightOfSlide = function getHeightOfSlide(slide) {\n  if (!slide) {\n    return 0;\n  }\n\n  if (slide.children && slide.children.length > 0) {\n    var totalHeight = 0;\n\n    for (var i = 0; i < slide.children.length; ++i) {\n      totalHeight += slide.children[i].offsetHeight;\n    }\n\n    return totalHeight;\n  } else {\n    return slide.offsetHeight;\n  }\n}; // end - is exclusive\n\n\nexport var findMaxHeightSlideInRange = function findMaxHeightSlideInRange(slides, start, end) {\n  var maxHeight = 0;\n\n  if (slides.length === 0 || start < 0 || end < 0 || start > slides.length - 1 || end > slides.length) {\n    return maxHeight;\n  }\n\n  if (start < end) {\n    for (var i = start; i < end; i++) {\n      maxHeight = getMax(getHeightOfSlide(slides[i]), maxHeight);\n    }\n  } else if (start > end) {\n    // Finding max in a wrap around\n    for (var _i = start; _i < slides.length; _i++) {\n      maxHeight = getMax(getHeightOfSlide(slides[_i]), maxHeight);\n    }\n\n    for (var _i2 = 0; _i2 < end; _i2++) {\n      maxHeight = getMax(getHeightOfSlide(slides[_i2]), maxHeight);\n    }\n  } else {\n    // start === end\n    maxHeight = getHeightOfSlide(slides[start]);\n  }\n\n  return maxHeight;\n};\nexport var findCurrentHeightSlide = function findCurrentHeightSlide(currentSlide, slidesToShow, alignment, wrapAround, slides) {\n  if (slidesToShow > 1) {\n    var startIndex = currentSlide;\n    var lastIndex = Math.min(Math.ceil(slidesToShow) + currentSlide, slides.length);\n    var offset = alignment === 'center' ? (slidesToShow - 1) / 2 : slidesToShow - 1;\n\n    switch (alignment) {\n      case 'center':\n        startIndex = Math.floor(currentSlide - offset);\n        lastIndex = Math.ceil(currentSlide + offset) + 1;\n        break;\n\n      case 'right':\n        startIndex = Math.floor(currentSlide - offset);\n        lastIndex = currentSlide + 1;\n        break;\n\n      case 'left':\n        startIndex = Math.floor(currentSlide + offset);\n        lastIndex = Math.ceil(currentSlide + offset) + 1;\n        break;\n    } // inclusive\n\n\n    startIndex = wrapAround && startIndex < 0 ? slides.length + startIndex : Math.max(startIndex, 0); // exclusive\n\n    lastIndex = wrapAround && lastIndex > slides.length ? lastIndex - slides.length : Math.min(lastIndex, slides.length);\n    return findMaxHeightSlideInRange(slides, startIndex, lastIndex);\n  } else {\n    return getHeightOfSlide(slides[currentSlide]);\n  }\n};\nexport var calculateSlideHeight = function calculateSlideHeight(props, state) {\n  var childNodes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  var heightMode = props.heightMode,\n      vertical = props.vertical,\n      initialSlideHeight = props.initialSlideHeight,\n      wrapAround = props.wrapAround;\n  var slidesToShow = state.slidesToShow,\n      currentSlide = state.currentSlide,\n      cellAlign = state.cellAlign;\n  var firstSlide = childNodes[0];\n\n  if (firstSlide && heightMode === 'first') {\n    return vertical ? getHeightOfSlide(firstSlide) * slidesToShow : getHeightOfSlide(firstSlide);\n  }\n\n  if (heightMode === 'max') {\n    return findMaxHeightSlideInRange(childNodes, 0, childNodes.length);\n  }\n\n  if (heightMode === 'current') {\n    return findCurrentHeightSlide(currentSlide, slidesToShow, cellAlign, wrapAround, childNodes);\n  }\n\n  return initialSlideHeight || 100;\n};","map":{"version":3,"sources":["/Users/zionwang/Projects/consensus/node_modules/nuka-carousel/es/utilities/bootstrapping-utilities.js"],"names":["React","getValidChildren","children","Children","toArray","getMax","a","b","getHeightOfSlide","slide","length","totalHeight","i","offsetHeight","findMaxHeightSlideInRange","slides","start","end","maxHeight","_i","_i2","findCurrentHeightSlide","currentSlide","slidesToShow","alignment","wrapAround","startIndex","lastIndex","Math","min","ceil","offset","floor","max","calculateSlideHeight","props","state","childNodes","arguments","undefined","heightMode","vertical","initialSlideHeight","cellAlign","firstSlide"],"mappings":"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","sourcesContent":["import React from 'react';\nexport var getValidChildren = function getValidChildren(children) {\n  // .toArray automatically removes invalid React children\n  return React.Children.toArray(children);\n};\n\nvar getMax = function getMax(a, b) {\n  return a > b ? a : b;\n};\n\nvar getHeightOfSlide = function getHeightOfSlide(slide) {\n  if (!slide) {\n    return 0;\n  }\n\n  if (slide.children && slide.children.length > 0) {\n    var totalHeight = 0;\n\n    for (var i = 0; i < slide.children.length; ++i) {\n      totalHeight += slide.children[i].offsetHeight;\n    }\n\n    return totalHeight;\n  } else {\n    return slide.offsetHeight;\n  }\n}; // end - is exclusive\n\n\nexport var findMaxHeightSlideInRange = function findMaxHeightSlideInRange(slides, start, end) {\n  var maxHeight = 0;\n\n  if (slides.length === 0 || start < 0 || end < 0 || start > slides.length - 1 || end > slides.length) {\n    return maxHeight;\n  }\n\n  if (start < end) {\n    for (var i = start; i < end; i++) {\n      maxHeight = getMax(getHeightOfSlide(slides[i]), maxHeight);\n    }\n  } else if (start > end) {\n    // Finding max in a wrap around\n    for (var _i = start; _i < slides.length; _i++) {\n      maxHeight = getMax(getHeightOfSlide(slides[_i]), maxHeight);\n    }\n\n    for (var _i2 = 0; _i2 < end; _i2++) {\n      maxHeight = getMax(getHeightOfSlide(slides[_i2]), maxHeight);\n    }\n  } else {\n    // start === end\n    maxHeight = getHeightOfSlide(slides[start]);\n  }\n\n  return maxHeight;\n};\nexport var findCurrentHeightSlide = function findCurrentHeightSlide(currentSlide, slidesToShow, alignment, wrapAround, slides) {\n  if (slidesToShow > 1) {\n    var startIndex = currentSlide;\n    var lastIndex = Math.min(Math.ceil(slidesToShow) + currentSlide, slides.length);\n    var offset = alignment === 'center' ? (slidesToShow - 1) / 2 : slidesToShow - 1;\n\n    switch (alignment) {\n      case 'center':\n        startIndex = Math.floor(currentSlide - offset);\n        lastIndex = Math.ceil(currentSlide + offset) + 1;\n        break;\n\n      case 'right':\n        startIndex = Math.floor(currentSlide - offset);\n        lastIndex = currentSlide + 1;\n        break;\n\n      case 'left':\n        startIndex = Math.floor(currentSlide + offset);\n        lastIndex = Math.ceil(currentSlide + offset) + 1;\n        break;\n    } // inclusive\n\n\n    startIndex = wrapAround && startIndex < 0 ? slides.length + startIndex : Math.max(startIndex, 0); // exclusive\n\n    lastIndex = wrapAround && lastIndex > slides.length ? lastIndex - slides.length : Math.min(lastIndex, slides.length);\n    return findMaxHeightSlideInRange(slides, startIndex, lastIndex);\n  } else {\n    return getHeightOfSlide(slides[currentSlide]);\n  }\n};\nexport var calculateSlideHeight = function calculateSlideHeight(props, state) {\n  var childNodes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  var heightMode = props.heightMode,\n      vertical = props.vertical,\n      initialSlideHeight = props.initialSlideHeight,\n      wrapAround = props.wrapAround;\n  var slidesToShow = state.slidesToShow,\n      currentSlide = state.currentSlide,\n      cellAlign = state.cellAlign;\n  var firstSlide = childNodes[0];\n\n  if (firstSlide && heightMode === 'first') {\n    return vertical ? getHeightOfSlide(firstSlide) * slidesToShow : getHeightOfSlide(firstSlide);\n  }\n\n  if (heightMode === 'max') {\n    return findMaxHeightSlideInRange(childNodes, 0, childNodes.length);\n  }\n\n  if (heightMode === 'current') {\n    return findCurrentHeightSlide(currentSlide, slidesToShow, cellAlign, wrapAround, childNodes);\n  }\n\n  return initialSlideHeight || 100;\n};"]},"metadata":{},"sourceType":"module"}